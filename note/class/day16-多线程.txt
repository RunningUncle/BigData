多线程:

默认情况下有主线程和垃圾回收线程,但是这两个线程默认都是由JVM控制的,为了完成我们自己的任务,所以我们创建自己的线程
所以线程面向对象后形成的类叫Thread,在Thread内部负责工作的方法叫run方法,默认这个方法会被自动调用
主线程默认名字叫main

注意:当我们通过线程对象调用run方法时,这个run方法将会被当作普通方法执行,并不是对应线程的任务区.

多线程的生命周期:
	1.创建(new)
	2.就绪(start)
	3.运行(执行run方法)
	4.阻塞
	5.停止(stop)

4个售票员同时售票问题:
解决问题的两种方式
方式一:
	创建4个线程,让run方法在线程内部:
	缺点:线程与任务没有分离,虽然实现了4个人同时售票,但是操作不方便.

方式二:
	创建4个线程,再创建一个单独的任务类,将线程与任务"分离"
	
	
发生线程安全问题的条件:
1.多线程同时处在就绪状态
2.run方法中存在多行代码且在这多行代码中可能存在线程状态切换的情况(抢CPU)

给run方法代码枷锁,变成同步代码块,保证线程线程之间是互斥的
synchronized(锁对象){//这个锁对象范域围需要比这段代码的块大,最好是任务类的对象
	代码块
}

//4个售票员同时买票
 产生负数的原因:
 	1.多个线程操作了一个数据
 	2.共享语句有多条,一个线程抢到cpu,没有执行完,cpu被抢走,当再次抢到cpu的时候,会执行后面的语句,造成错误的发生
 解决方案:
 	在代码中使用同步代码块(同步锁)
 	解释:在某一段任务中,同一时间只允许有一个线程执行任务,其他线程即使抢到cpu也无法进入代码块,
 	          只已经进入代码块的线程执行完后,其他线程才能执行这个任务
 对象锁的要求:1.必须是对象 2.必须被多个线程共享
 同步代码块特点:由于每次都要判断锁,降低了整体的执行效率
 总结:什么情况会使用同步代码块?
 1.多个线程共享一个数据
 2.至少有两个线程
 

注意:父类的方法是同步代码块,子类继承该方法时,synchronized不会被继承过来,
	子类要想代码也具有同步,子类需要自己加锁

//两个人向同一个账户存钱


被枷锁的代码越少越好